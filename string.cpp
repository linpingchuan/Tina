#include "c.h"
// 每个函数返回一个指向永久占用的字符串的指针

// stringn对所有的不同的字符串进行管理,
// 它把所有的字符串存放在一个字符串表中，
// 保证每个不同的字符串只有一份副本，
// 该表中的任何字符不会被删除。
// 字符串表是一个长度为1024的哈希表。
// 每个哈希桶(bucket)都保存了一个字符串链表，
// 链表中的字符串的哈希值都是相同的。
// 考虑到字符串中可能包含null字符，
// 每个字符串表项还包括了该串的长度(放在len域中)
static struct _string {
	char *str;
	int len;
	struct _string *link;
} *buckets[1024];

// scatter是包含256个随机数的静态数组,
// 以帮助分布哈希函数值
// 传统建议:哈希表大小应该取一个素数。
// 而如果取成2的幂，编译器会工作的更快
// 因为掩码(masking)运算比求模运算更快
static int scatter[] = {	/* map characters to random values */
	2078917053, 143302914, 1027100827, 1953210302, 755253631,
	2002600785, 1405390230, 45248011, 1099951567, 433832350,
	2018585307, 438263339, 813528929, 1703199216, 618906479,
	573714703, 766270699, 275680090, 1510320440, 1583583926,
	1723401032, 1965443329, 1098183682, 1636505764, 980071615,
	1011597961, 643279273, 1315461275, 157584038, 1069844923,
	471560540, 89017443, 1213147837, 1498661368, 2042227746,
	1968401469, 1353778505, 1300134328, 2013649480, 306246424,
	1733966678, 1884751139, 744509763, 400011959, 1440466707,
	1363416242, 973726663, 59253759, 1639096332, 336563455,
	1642837685, 1215013716, 154523136, 593537720, 704035832,
	1134594751, 1605135681, 1347315106, 302572379, 1762719719,
	269676381, 774132919, 1851737163, 1482824219, 125310639,
	1746481261, 1303742040, 1479089144, 899131941, 1169907872,
	1785335569, 485614972, 907175364, 382361684, 885626931,
	200158423, 1745777927, 1859353594, 259412182, 1237390611,
	48433401, 1902249868, 304920680, 202956538, 348303940,
	1008956512, 1337551289, 1953439621, 208787970, 1640123668,
	1568675693, 478464352, 266772940, 1272929208, 1961288571,
	392083579, 871926821, 1117546963, 1871172724, 1771058762,
	139971187, 1509024645, 109190086, 1047146551, 1891386329,
	994817018, 1247304975, 1489680608, 706686964, 1506717157,
	579587572, 755120366, 1261483377, 884508252, 958076904,
	1609787317, 1893464764, 148144545, 1415743291, 2102252735,
	1788268214, 836935336, 433233439, 2055041154, 2109864544,
	247038362, 299641085, 834307717, 1364585325, 23330161,
	457882831, 1504556512, 1532354806, 567072918, 404219416,
	1276257488, 1561889936, 1651524391, 618454448, 121093252,
	1010757900, 1198042020, 876213618, 124757630, 2082550272,
	1834290522, 1734544947, 1828531389, 1982435068, 1002804590,
	1783300476, 1623219634, 1839739926, 69050267, 1530777140,
	1802120822, 316088629, 1830418225, 488944891, 1680673954,
	1853748387, 946827723, 1037746818, 1238619545, 1513900641,
	1441966234, 367393385, 928306929, 946006977, 985847834,
	1049400181, 1956764878, 36406206, 1925613800, 2081522508,
	2118956479, 1612420674, 1668583807, 1800004220, 1447372094,
	523904750, 1435821048, 923108080, 216161028, 1504871315,
	306401572, 2018281851, 1820959944, 2136819798, 359743094,
	1354150250, 1843084537, 1306570817, 244413420, 934220434,
	672987810, 1686379655, 1301613820, 1601294739, 484902984,
	139978006, 503211273, 294184214, 176384212, 281341425,
	228223074, 147857043, 1893762099, 1896806882, 1947861263,
	1193650546, 273227984, 1236198663, 2116758626, 489389012,
	593586330, 275676551, 360187215, 267062626, 265012701,
	719930310, 1621212876, 2108097238, 2026501127, 1865626297,
	894834024, 552005290, 1404522304, 48964196, 5816381,
	1889425288, 188942202, 509027654, 36125855, 365326415,
	790369079, 264348929, 513183458, 536647531, 13672163,
	313561074, 1730298077, 286900147, 1549759737, 1699573055,
	776289160, 2143346068, 1975249606, 1136476375, 262925046,
	92778659, 1856406685, 1884137923, 53392249, 1735424165,
	1602280572
};

// 对以null结尾的字符串str进行复制
char *string(const char* str) {
	const char *s;
	for (s = str;*s;s++)
		;
	return stringn(str, s - str);
}

// 对字符串str的前len个字节进行复制
// 如果字符串不在字符串表中，则stringn把该字符放入表中,
// 并返回该字符串地址；否则直接返回其地址。
char *stringn(const char *str, int len) {
	int i;
	// h为str对应的哈希链,
	// stringn对该链进行遍历，
	// 比较链上长度与str相等的字符串是否和str完全相同
	unsigned int h;
	// end指向str最后一个字符之后的字符
	const char *end;
	struct _string *p;

	assert(str);

	// 直接把end所指的字符作为数组下标可能有问题,
	// 因为该字符也许会被按符号扩展而变成一个负整数
	// 所以，先把end转换成一个指向无符号字符的指针以避免这种可能的错误
	// 这段代码还将end指针置于str的最后一个字符后面的字符位置上
	for (h = 0, i = len, end = str;i > 0;i--)
		h = (h << 1) + scatter[*(unsigned char*)end++];

	h &= NELEMS(buckets) - 1;
	for (p = buckets[h];p;p = p->link)
		if (len == p->len) {
			const char *s1 = str;
			char *s2 = p->str;
			do {
				if (s1 == end)
					return p->str;
			} while (*s1++ == *s2++);
		}
	{
		// stringn把新的字符串存放在永久分配的内存块中,
		// 内存块最少有4KB.
		// PERM表示永久的存储分配区。

		// 静态变量next指向当前内存块的下一个待分配的字节
		// strlimit指向当前内存最后一个字节之后的字节。
		// 如果有必要，会分配一个新的内存块，
		// 并增加一个新的字符串，一边复制str，一边增加next
		// 并把该字符串连接到相应的哈希链中。
		static char *next, *strlimit;
		if (len + 1 + next >= strlimit) {
			int n = len + 4 * 1024;
			next = (char *)allocate(n, PERM);
			strlimit = next + n;
		}
		p = (_string *)allocate(sizeof *(p), PERM);
		p->len = len;
		for (p->str = next;str < end;)
			*next++ = *str++;
		*next++ = 0;
		p->link = buckets[h];
		return p->str;
	}
}

// 把整数n按十进制转换成字符串形式，并返回
// stringd 把参数d转换成字符串，并存放在一个私有缓冲区
// 然后调用stringn返回相应的字符串。
char *stringd(long n) {
	char str[25], *s = str + sizeof(str);
	unsigned long m;
	// 首先把n的绝对值赋给m，如果n是最小的整数，
	// 由于任何2的补码符号整数都无法表示其绝对值，
	// 因此这种情况需要特殊处理。
	if (n == LONG_MIN)
		m = (unsigned long)LONG_MAX + 1;
	else if (n < 0)
		m = -n;
	else
		m = n;
	// 字符串的建立是从后向前的，
	// 最后一个数字游戏
	do
		*--s = m % 10 + '0';
	while ((m /= 10) != 0);
	if (n < 0)
		*--s = '-';
	return stringn(s, str + sizeof(str) - s);
}
